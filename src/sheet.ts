import 'dotenv/config';
import { GoogleSpreadsheet, GoogleSpreadsheetRow, GoogleSpreadsheetWorksheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library';
import { getTime } from './util';


// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.CLIENT_EMAIL,
    key: (process.env.API_KEY || "").replace(/\\\\n/g, '\n'),
    scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
    ],
});


const doc = new GoogleSpreadsheet(process.env.SPREADSHEET_ID || "", serviceAccountAuth);

let logSheet: GoogleSpreadsheetWorksheet | undefined;
let usersSheet: GoogleSpreadsheetWorksheet | undefined;
let connectPromise: Promise<boolean> | undefined;

type UsersRowData = {
    pin: string;
    fname: string;
    lname: string;
    email: string;
    type: string;
    gender: string;
    login: string;
    logout: string;
    hours: number;
    total: number;
    loggedin: boolean;
};

export async function connect() {
    if (connectPromise) return connectPromise;

    connectPromise = (async () => {
        await doc.loadInfo();

        const users = doc.sheetsByIndex[0];
        const log = doc.sheetsByIndex[1];

        if (!users || !log) {
            throw new Error('Required sheets not found');
        }

        usersSheet = users;
        logSheet = log;

        await users.setHeaderRow([
            'pin',
            'fname',
            'lname',
            'email',
            'type',
            'gender',
            'login',
            'logout',
            'hours',
            'total',
            'loggedin'
        ]);

        // ─────────────────────────────────────────────
        // Load rows
        // ─────────────────────────────────────────────
        const userRows = await users.getRows<UsersRowData>();
        let logRows = await log.getRows();

        // ─────────────────────────────────────────────
        // Build authoritative user map
        // ─────────────────────────────────────────────
        const usersByPin = new Map<string, GoogleSpreadsheetRow<UsersRowData>>();
        for (const row of userRows) {
            const pin = row.get('pin');
            if (pin) usersByPin.set(pin, row);
        }

        // ─────────────────────────────────────────────
        // Build log pin set
        // ─────────────────────────────────────────────
        const logPins = new Set<string>();
        for (const row of logRows) {
            const pin = row['_rawData']?.[0];
            if (pin) logPins.add(pin);
        }

        // ─────────────────────────────────────────────
        // 1. Add missing users to log (pin + fname + lname)
        // ─────────────────────────────────────────────
        const rowsToAdd: any[][] = [];

        for (const [pin, user] of usersByPin) {
            if (!logPins.has(pin)) {
                rowsToAdd.push([
                    pin,
                    user.get('fname'),
                    user.get('lname')
                ]);
            }
        }

        if (rowsToAdd.length > 0) {
            await log.addRows(rowsToAdd);
        }

        // Reload after inserts
        logRows = await log.getRows();

        // ─────────────────────────────────────────────
        // 2. Always sync fname/lname for existing pins
        // ─────────────────────────────────────────────
        for (const row of logRows) {
            const pin = row['_rawData']?.[0];
            if (!pin) continue;

            const user = usersByPin.get(pin);
            if (!user) continue;

            const fname = user.get('fname');
            const lname = user.get('lname');

            let dirty = false;

            if (row['_rawData'][1] !== fname) {
                row['_rawData'][1] = fname;
                dirty = true;
            }

            if (row['_rawData'][2] !== lname) {
                row['_rawData'][2] = lname;
                dirty = true;
            }

            if (dirty) {
                await row.save();
            }
        }

        // ─────────────────────────────────────────────
        // 3. Identify orphan rows (pins not in users)
        // ─────────────────────────────────────────────
        const orphanRows = logRows.filter(row => {
            const pin = row['_rawData']?.[0];
            return pin && !usersByPin.has(pin);
        });

        if (orphanRows.length > 0) {
            // Load grid
            await log.loadCells();

            const originalRowCount = log.rowCount;
            const newRowCount = originalRowCount + orphanRows.length;

            // Resize sheet
            await log.resize({
                rowCount: newRowCount,
                columnCount: log.columnCount
            });

            // Reload grid after resize
            await log.loadCells();

            let writeRow = originalRowCount;

            // Copy orphan rows to bottom + color red
            for (const row of orphanRows) {
                const sourceRowIndex = row.rowNumber - 1;

                for (let col = 0; col < log.columnCount; col++) {
                    const src = log.getCell(sourceRowIndex, col);
                    const dst = log.getCell(writeRow, col);

                    dst.value = src.value;
                    dst.textFormat = {
                        foregroundColor: { red: 1, green: 0, blue: 0 }
                    };
                }

                writeRow++;
            }

            // Clear original orphan rows
            for (const row of orphanRows) {
                const sourceRowIndex = row.rowNumber - 1;
                for (let col = 0; col < log.columnCount; col++) {
                    log.getCell(sourceRowIndex, col).value = null;
                }
            }

            await log.saveUpdatedCells();
        }

        // ─────────────────────────────────────────────
        // 4. Remove blank rows (no pin)
        // ─────────────────────────────────────────────
        const finalLogRows = await log.getRows();

        const rowsToDelete = finalLogRows.filter(
            row => !row['_rawData']?.[0]
        );

        // Delete bottom → top to preserve indices
        for (const row of rowsToDelete.reverse()) {
            await row.delete();
        }

        return true;
    })();

    return connectPromise;
}



export async function getUserFromPin(pin: string) {
    await connectPromise;
    if (usersSheet) {
        const rows = await usersSheet.getRows<UsersRowData>();
        const user = rows.find(row => row.get('pin') == pin);
        return user;
    }
}

export async function getDateIndex() {
    await connectPromise;
    if (logSheet) {
        await logSheet.loadCells();

        const now = getTime();
        const date = now.toISOString().split('T')[0];

        let i;
        for (i = 0; i < logSheet.columnCount; i++) {
            const cell = logSheet.getCell(0, i);

            if (cell.formattedValue == date) {
                return i;
            } else if (cell.value == null) {
                cell.value = Math.floor(now.getTime() / 8.64e7) + 25569;
                console.log(Math.floor(now.getTime() / 8.64e7));
                logSheet.saveUpdatedCells();
                return i;
            }
        }

        // If the date is not found, add a new column
        await logSheet.resize({
            columnCount: logSheet.columnCount + 1,
            rowCount: logSheet.rowCount
        });
        let newCell = logSheet.getCell(0, i + 1);
        newCell.value = Math.floor(now.getTime() / 8.64e7) + 25569;
        return i + 1;
    } else {
        throw new Error('Sheet not connected');
    }
}

export async function setHoursForDay(pin: string, hours: number) {
    const col = await getDateIndex();
    if (logSheet) {
        await logSheet.loadCells();

        let row;
        for (let i = 0; i < logSheet.rowCount; i++) {
            const cell = logSheet.getCell(i, 0);
            if (cell.value == pin) {
                row = i;
                break;
            }
        }

        if (row) {
            const cell = logSheet.getCell(row, col);
            if (cell.numberValue && cell.numberValue > 0) {
                hours = hours + cell.numberValue;
            }
            cell.value = hours;
            logSheet.saveUpdatedCells();
        } else {
            throw new Error('User not found');
        }
    } else {
        throw new Error('Sheet not connected');
    }
}

export async function getStats() {
    await connectPromise;
    let stats: UserStats[] = [];
    let overall: Omit<UserStats, 'pin' | 'name'> = {
        hours: 0,
        attended: 0,
        excused: 0,
        absent: 0,
        attendance: 0,
        attendanceWithExcused: 0,
        months: {}
    };

    if (logSheet) {
        const rows = await logSheet.getRows<UsersRowData>();
        for (let row of rows) {
            const user: UserStats = {
                // @ts-ignore
                pin: row.get('Student ID'),
                // @ts-ignore
                name: `${row.get('First Name')} ${row.get('Last Name')}`,
                hours: 0,
                attended: 0,
                excused: 0,
                absent: 0,
                attendance: 0,
                attendanceWithExcused: 0,
                months: {}
            };

            for (let i = 3; i < row['_rawData'].length; i++) {
                let month = parseInt(logSheet.headerValues[i].split('-')[1]);
                if (!user.months[month]) {
                    user.months[month] = {
                        hours: 0,
                        attended: 0,
                        excused: 0,
                        absent: 0,
                        attendance: 0,
                        attendanceWithExcused: 0
                    };
                }
                if (!overall.months[month]) {
                    overall.months[month] = {
                        hours: 0,
                        attended: 0,
                        excused: 0,
                        absent: 0,
                        attendance: 0,
                        attendanceWithExcused: 0
                    };
                }

                let day = row['_rawData'][i];

                if (!isNaN(day) && day > 0) {
                    user.attended++;
                    user.months[month].attended++;
                    user.hours += parseFloat(day);
                    user.months[month].hours += parseFloat(day);
                    overall.attended++;
                    overall.hours += parseFloat(day);
                    overall.months[month].attended++;
                    overall.months[month].hours += parseFloat(day);
                } else if (day == 'E') {
                    user.excused++;
                    user.months[month].excused++;
                    overall.excused++;
                    overall.months[month].excused++;
                } else {
                    user.absent++;
                    user.months[month].absent++;
                    overall.absent++;
                    overall.months[month].absent++;
                }
            }

            user.attendance = (user.attended / (user.attended + user.excused + user.absent)) * 100;
            user.attendanceWithExcused = ((user.attended + user.excused) / (user.attended + user.excused + user.absent)) * 100;
            overall.attendance = (overall.attended / (overall.attended + overall.excused + overall.absent)) * 100;
            overall.attendanceWithExcused = ((overall.attended + overall.excused) / (overall.attended + overall.excused + overall.absent)) * 100;

            for (let month in user.months) {
                let m = user.months[month];
                m.attendance = (m.attended / (m.attended + m.excused + m.absent)) * 100;
                m.attendanceWithExcused = ((m.attended + m.excused) / (m.attended + m.excused + m.absent)) * 100;
                overall.months[month].attendance = (overall.months[month].attended / (overall.months[month].attended + overall.months[month].excused + overall.months[month].absent)) * 100;
                overall.months[month].attendanceWithExcused = ((overall.months[month].attended + overall.months[month].excused) / (overall.months[month].attended + overall.months[month].excused + overall.months[month].absent)) * 100;
            }

            stats.push(user);
        }
        return { overall, stats };
    } else {
        throw new Error('Sheet not connected');
    }
}

interface UserStats {
    pin: string;
    name: string;
    hours: number;
    attended: number;
    excused: number;
    absent: number;
    attendance: number;
    attendanceWithExcused: number;
    months: {
        [key: number]: {
            hours: number;
            attended: number;
            excused: number;
            absent: number;
            attendance: number;
            attendanceWithExcused: number;
        };
    };
}

interface Meetings {
    [key: number]: number;
}
