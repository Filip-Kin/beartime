import 'dotenv/config';
import { GoogleSpreadsheet, GoogleSpreadsheetWorksheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library';
import { getTime } from './util';


// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.CLIENT_EMAIL,
    key: (process.env.API_KEY || "").replace(/\\n/g, '\n'),
    scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
    ],
});

const doc = new GoogleSpreadsheet(process.env.SPREADSHEET_ID || "", serviceAccountAuth);

let logSheet: GoogleSpreadsheetWorksheet | undefined;
let currentSheet: GoogleSpreadsheetWorksheet | undefined;
let connectPromise: Promise<boolean> | undefined;

type UsersRowData = {
    pin: string;
    fname: string;
    lname: string;
    email: string;
    type: string;
    gender: string;
    login: string;
    logout: string;
    hours: number;
    total: number;
    loggedin: boolean;
};

export async function connect() {
    connectPromise = new Promise(async (resolve, reject) => {
        await doc.loadInfo(); // loads document properties and worksheets

        logSheet = doc.sheetsByIndex[0];
        currentSheet = doc.sheetsByIndex[1];
        currentSheet.setHeaderRow(['pin', 'fname', 'lname', 'email', 'type', 'gender', 'login', 'logout', 'hours', 'total', 'loggedin']);
        resolve(true);
    });
}

export async function getUserFromPin(pin: string) {
    await connectPromise;
    if (currentSheet) {
        const rows = await currentSheet.getRows<UsersRowData>();
        const user = rows.find(row => row.get('pin') == pin);
        return user;
    }
}

export async function getDateIndex() {
    await connectPromise;
    if (logSheet) {
        await logSheet.loadCells();

        const now = getTime();
        const date = now.toISOString().split('T')[0];

        let i;
        for (i = 0; i < logSheet.columnCount; i++) {
            const cell = logSheet.getCell(0, i);

            if (cell.formattedValue == date) {
                return i;
            } else if (cell.value == null) {
                cell.value = Math.floor(now.getTime() / 8.64e7) + 25569;
                console.log(Math.floor(now.getTime() / 8.64e7));
                logSheet.saveUpdatedCells();
                return i;
            }
        }

        // If the date is not found, add a new column
        await logSheet.resize({
            columnCount: logSheet.columnCount + 1,
            rowCount: logSheet.rowCount
        });
        let newCell = logSheet.getCell(0, i + 1);
        newCell.value = Math.floor(now.getTime() / 8.64e7) + 25569;
        return i + 1;
    } else {
        throw new Error('Sheet not connected');
    }
}

export async function setHoursForDay(pin: string, hours: number) {
    const col = await getDateIndex();
    if (logSheet) {
        await logSheet.loadCells();

        let row;
        for (let i = 0; i < logSheet.rowCount; i++) {
            const cell = logSheet.getCell(i, 0);
            if (cell.value == pin) {
                row = i;
                break;
            }
        }

        if (row) {
            const cell = logSheet.getCell(row, col);
            if (cell.numberValue && cell.numberValue > 0) {
                hours = hours + cell.numberValue;
            }
            cell.value = hours;
            logSheet.saveUpdatedCells();
        } else {
            throw new Error('User not found');
        }
    } else {
        throw new Error('Sheet not connected');
    }
}

export async function getStats() {
    await connectPromise;
    let stats: UserStats[] = [];
    let overall: Omit<UserStats, 'pin' | 'name'> = {
        hours: 0,
        attended: 0,
        excused: 0,
        absent: 0,
        attendance: 0,
        attendanceWithExcused: 0,
        months: {}
    };

    if (logSheet) {
        const rows = await logSheet.getRows<UsersRowData>();
        for (let row of rows) {
            const user: UserStats = {
                // @ts-ignore
                pin: row.get('Student ID'),
                // @ts-ignore
                name: `${row.get('First Name')} ${row.get('Last Name')}`,
                hours: 0,
                attended: 0,
                excused: 0,
                absent: 0,
                attendance: 0,
                attendanceWithExcused: 0,
                months: {}
            };

            for (let i = 3; i < row['_rawData'].length; i++) {
                let month = parseInt(logSheet.headerValues[i].split('-')[1]);
                if (!user.months[month]) {
                    user.months[month] = {
                        hours: 0,
                        attended: 0,
                        excused: 0,
                        absent: 0,
                        attendance: 0,
                        attendanceWithExcused: 0
                    };
                }
                if (!overall.months[month]) {
                    overall.months[month] = {
                        hours: 0,
                        attended: 0,
                        excused: 0,
                        absent: 0,
                        attendance: 0,
                        attendanceWithExcused: 0
                    };
                }

                let day = row['_rawData'][i];

                if (!isNaN(day) && day > 0) {
                    user.attended++;
                    user.months[month].attended++;
                    user.hours += parseFloat(day);
                    user.months[month].hours += parseFloat(day);
                    overall.attended++;
                    overall.hours += parseFloat(day);
                    overall.months[month].attended++;
                    overall.months[month].hours += parseFloat(day);
                } else if (day == 'E') {
                    user.excused++;
                    user.months[month].excused++;
                    overall.excused++;
                    overall.months[month].excused++;
                } else {
                    user.absent++;
                    user.months[month].absent++;
                    overall.absent++;
                    overall.months[month].absent++;
                }
            }

            user.attendance = (user.attended / (user.attended + user.excused + user.absent)) * 100;
            user.attendanceWithExcused = ((user.attended + user.excused) / (user.attended + user.excused + user.absent)) * 100;
            overall.attendance = (overall.attended / (overall.attended + overall.excused + overall.absent)) * 100;
            overall.attendanceWithExcused = ((overall.attended + overall.excused) / (overall.attended + overall.excused + overall.absent)) * 100;

            for (let month in user.months) {
                let m = user.months[month];
                m.attendance = (m.attended / (m.attended + m.excused + m.absent)) * 100;
                m.attendanceWithExcused = ((m.attended + m.excused) / (m.attended + m.excused + m.absent)) * 100;
                overall.months[month].attendance = (overall.months[month].attended / (overall.months[month].attended + overall.months[month].excused + overall.months[month].absent)) * 100;
                overall.months[month].attendanceWithExcused = ((overall.months[month].attended + overall.months[month].excused) / (overall.months[month].attended + overall.months[month].excused + overall.months[month].absent)) * 100;
            }

            stats.push(user);
        }
        return { overall, stats };
    } else {
        throw new Error('Sheet not connected');
    }
}

interface UserStats {
    pin: string;
    name: string;
    hours: number;
    attended: number;
    excused: number;
    absent: number;
    attendance: number;
    attendanceWithExcused: number;
    months: {
        [key: number]: {
            hours: number;
            attended: number;
            excused: number;
            absent: number;
            attendance: number;
            attendanceWithExcused: number;
        };
    };
}

interface Meetings {
    [key: number]: number;
}
